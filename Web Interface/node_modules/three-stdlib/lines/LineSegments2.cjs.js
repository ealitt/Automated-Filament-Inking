"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),i=require("three"),e=require("./LineSegmentsGeometry.cjs.js"),s=require("./LineMaterial.cjs.js");function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var a=r(t);class n extends i.Mesh{constructor(t=new e.LineSegmentsGeometry,r=new s.LineMaterial({color:16777215*Math.random()})){super(t,r),a.default(this,"type","LineSegments2"),a.default(this,"isLineSegments2",!0),a.default(this,"distStart",new i.Vector3),a.default(this,"distEnd",new i.Vector3),a.default(this,"computeLineDistances",(()=>{const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,r=new Float32Array(2*e.data.count);for(let t=0,i=0,a=e.data.count;t<a;t++,i+=2)this.distStart.fromBufferAttribute(e,t),this.distEnd.fromBufferAttribute(s,t),r[i]=0===i?0:r[i-1],r[i+1]=r[i]+this.distStart.distanceTo(this.distEnd);const a=new i.InstancedInterleavedBuffer(r,2,1);return t.setAttribute("instanceDistanceStart",new i.InterleavedBufferAttribute(a,1,0)),t.setAttribute("instanceDistanceEnd",new i.InterleavedBufferAttribute(a,1,1)),this})),a.default(this,"rayStart",new i.Vector4),a.default(this,"rayEnd",new i.Vector4),a.default(this,"ssOrigin",new i.Vector4),a.default(this,"ssOrigin3",new i.Vector3),a.default(this,"mvMatrix",new i.Matrix4),a.default(this,"line",new i.Line3),a.default(this,"closestPoint",new i.Vector3),a.default(this,"raycast",((t,e)=>{null===t.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');const s=t.ray,r=t.camera,a=r.projectionMatrix,n=this.geometry,h=this.material,l=h.resolution,o=h.linewidth+0,d=n.attributes.instanceStart,y=n.attributes.instanceEnd,c=-r.near;s.at(1,this.ssOrigin),this.ssOrigin.w=1,this.ssOrigin.applyMatrix4(r.matrixWorldInverse),this.ssOrigin.applyMatrix4(a),this.ssOrigin.multiplyScalar(1/this.ssOrigin.w),this.ssOrigin.x*=l.x/2,this.ssOrigin.y*=l.y/2,this.ssOrigin.z=0,this.ssOrigin3.set(this.ssOrigin.x,this.ssOrigin.y,this.ssOrigin.z);const u=this.matrixWorld;this.mvMatrix.multiplyMatrices(r.matrixWorldInverse,u);for(let t=0,r=d.count;t<r;t++){this.rayStart.fromBufferAttribute(d,t),this.rayEnd.fromBufferAttribute(y,t),this.rayStart.w=1,this.rayEnd.w=1,this.rayStart.applyMatrix4(this.mvMatrix),this.rayEnd.applyMatrix4(this.mvMatrix);if(this.rayStart.z>c&&this.rayEnd.z>c)continue;if(this.rayStart.z>c){const t=this.rayStart.z-this.rayEnd.z,i=(this.rayStart.z-c)/t;this.rayStart.lerp(this.rayEnd,i)}else if(this.rayEnd.z>c){const t=this.rayEnd.z-this.rayStart.z,i=(this.rayEnd.z-c)/t;this.rayEnd.lerp(this.rayStart,i)}this.rayStart.applyMatrix4(a),this.rayEnd.applyMatrix4(a),this.rayStart.multiplyScalar(1/this.rayStart.w),this.rayEnd.multiplyScalar(1/this.rayEnd.w),this.rayStart.x*=l.x/2,this.rayStart.y*=l.y/2,this.rayEnd.x*=l.x/2,this.rayEnd.y*=l.y/2,this.line.start.set(this.rayStart.x,this.rayStart.y,this.rayStart.z),this.line.start.z=0,this.line.end.set(this.rayEnd.x,this.rayEnd.y,this.rayEnd.z),this.line.end.z=0;const r=this.line.closestPointToPointParameter(this.ssOrigin3,!0);this.line.at(r,this.closestPoint);const n=i.MathUtils.lerp(this.rayStart.z,this.rayEnd.z,r),h=n>=-1&&n<=1,f=this.ssOrigin3.distanceTo(this.closestPoint)<.5*o;if(h&&f){this.line.start.fromBufferAttribute(d,t),this.line.end.fromBufferAttribute(y,t),this.line.start.applyMatrix4(u),this.line.end.applyMatrix4(u);const r=new i.Vector3,a=new i.Vector3;s.distanceSqToSegment(this.line.start,this.line.end,a,r),e.push({distance:s.origin.distanceTo(a),point:a,face:null,faceIndex:t,object:this,uv:void 0,pointOnLine:r})}}}))}}exports.LineSegments2=n;

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),e=require("three");function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var i=r(t);class n extends e.InstancedBufferGeometry{constructor(){super(),i.default(this,"isLineSegmentsGeometry",!0),i.default(this,"type","LineSegmentsGeometry"),i.default(this,"boundingBox",null),i.default(this,"boundingSphere",null),i.default(this,"box",new e.Box3),i.default(this,"vector",new e.Vector3);this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new e.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new e.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,r=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),r.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let r;if(t instanceof Float32Array)r=t;else{if(!Array.isArray(t))return console.error("LineSegmentsGeometry.setPosition requires either a Float32Array or regular array of numbers"),this;r=new Float32Array(t)}const i=new e.InstancedInterleavedBuffer(r,6,1);return this.setAttribute("instanceStart",new e.InterleavedBufferAttribute(i,3,0)),this.setAttribute("instanceEnd",new e.InterleavedBufferAttribute(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let r;if(t instanceof Float32Array)r=t;else{if(!Array.isArray(t))return console.error("LineSegmentsGeometry.setColors requires either a Float32Array or regular array of numbers"),this;r=new Float32Array(t)}const i=new e.InstancedInterleavedBuffer(r,6,1);return this.setAttribute("instanceColorStart",new e.InterleavedBufferAttribute(i,3,0)),this.setAttribute("instanceColorEnd",new e.InterleavedBufferAttribute(i,3,3)),this}fromWireframeGeometry(t){return this.setPositions(Array.from(t.attributes.position.array)),this}fromEdgesGeometry(t){return this.setPositions(Array.from(t.attributes.position.array)),this}fromMesh(t){return this.fromWireframeGeometry(new e.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return e.isBufferGeometry&&this.setPositions(Array.from(e.attributes.position.array)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new e.Box3);const t=this.attributes.instanceStart,r=this.attributes.instanceEnd;void 0!==t&&void 0!==r&&(this.boundingBox.setFromBufferAttribute(t),this.box.setFromBufferAttribute(r),this.boundingBox.union(this.box))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new e.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,r=this.attributes.instanceEnd;if(void 0!==t&&void 0!==r){const e=this.boundingSphere.center;this.boundingBox&&this.boundingBox.getCenter(e);let i=0;for(let n=0,s=t.count;n<s;n++)this.vector.fromBufferAttribute(t,n),i=Math.max(i,e.distanceToSquared(this.vector)),this.vector.fromBufferAttribute(r,n),i=Math.max(i,e.distanceToSquared(this.vector));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}exports.LineSegmentsGeometry=n;

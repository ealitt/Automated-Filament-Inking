"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");exports.calcBSplineDerivatives=function(e,o,n,c,r){const l=r<e?r:e,s=[],i=this.findSpan(e,c,o),a=this.calcBasisFunctionDerivatives(i,c,e,l,o),f=[];for(let t=0;t<n.length;++t){const e=(u=n[t].clone()).w;u.x*=e,u.y*=e,u.z*=e,f[t]=u}for(let t=0;t<=l;++t){var u=f[i-e].clone().multiplyScalar(a[t][0]);for(let o=1;o<=e;++o)u.add(f[i-e+o].clone().multiplyScalar(a[t][o]));s[t]=u}for(let e=l+1;e<=r+1;++e)s[e]=new t.Vector4(0,0,0);return s},exports.calcBSplinePoint=function(e,o,n,c){const r=this.findSpan(e,c,o),l=this.calcBasisFunctions(r,c,e,o),s=new t.Vector4(0,0,0,0);for(let t=0;t<=e;++t){const o=n[r-e+t],c=l[t],i=o.w*c;s.x+=o.x*i,s.y+=o.y*i,s.z+=o.z*i,s.w+=o.w*c}return s},exports.calcBasisFunctionDerivatives=function(t,e,o,n,c){const r=[];for(let t=0;t<=o;++t)r[t]=0;const l=[];for(let t=0;t<=n;++t)l[t]=r.slice(0);const s=[];for(let t=0;t<=o;++t)s[t]=r.slice(0);s[0][0]=1;const i=r.slice(0),a=r.slice(0);for(let n=1;n<=o;++n){i[n]=e-c[t+1-n],a[n]=c[t+n]-e;let o=0;for(let t=0;t<n;++t){const e=a[t+1],c=i[n-t];s[n][t]=e+c;const r=s[t][n-1]/s[n][t];s[t][n]=o+e*r,o=c*r}s[n][n]=o}for(let t=0;t<=o;++t)l[0][t]=s[t][o];for(let t=0;t<=o;++t){let e=0,c=1;const i=[];for(let t=0;t<=o;++t)i[t]=r.slice(0);i[0][0]=1;for(let r=1;r<=n;++r){let n=0;const a=t-r,u=o-r;t>=r&&(i[c][0]=i[e][0]/s[u+1][a],n=i[c][0]*s[a][u]);const v=t-1<=u?r-1:o-t;for(let t=a>=-1?1:-a;t<=v;++t)i[c][t]=(i[e][t]-i[e][t-1])/s[u+1][a+t],n+=i[c][t]*s[a+t][u];t<=u&&(i[c][r]=-i[e][r-1]/s[u+1][t],n+=i[c][r]*s[t][u]),l[r][t]=n;var f=e;e=c,c=f}}var u=o;for(let t=1;t<=n;++t){for(let e=0;e<=o;++e)l[t][e]*=u;u*=o-t}return l},exports.calcBasisFunctions=function(t,e,o,n){const c=[],r=[],l=[];c[0]=1;for(let s=1;s<=o;++s){r[s]=e-n[t+1-s],l[s]=n[t+s]-e;let o=0;for(let t=0;t<s;++t){const e=l[t+1],n=r[s-t],i=c[t]/(e+n);c[t]=o+e*i,o=n*i}c[s]=o}return c},exports.calcKoverI=function(t,e){let o=1;for(let e=2;e<=t;++e)o*=e;let n=1;for(let t=2;t<=e;++t)n*=t;for(let o=2;o<=t-e;++o)n*=o;return o/n},exports.calcNURBSDerivatives=function(t,e,o,n,c){const r=this.calcBSplineDerivatives(t,e,o,n,c);return this.calcRationalCurveDerivatives(r)},exports.calcRationalCurveDerivatives=function(e){const o=e.length,n=[],c=[];for(let r=0;r<o;++r){const o=e[r];n[r]=new t.Vector3(o.x,o.y,o.z),c[r]=o.w}const r=[];for(let t=0;t<o;++t){const e=n[t].clone();for(let o=1;o<=t;++o)e.sub(r[t-o].clone().multiplyScalar(this.calcKoverI(t,o)*c[o]));r[t]=e.divideScalar(c[0])}return r},exports.calcSurfacePoint=function(e,o,n,c,r,l,s,i){const a=this.findSpan(e,l,n),f=this.findSpan(o,s,c),u=this.calcBasisFunctions(a,l,e,n),v=this.calcBasisFunctions(f,s,o,c),p=[];for(let n=0;n<=o;++n){p[n]=new t.Vector4(0,0,0,0);for(let t=0;t<=e;++t){const c=r[a-e+t][f-o+n].clone(),l=c.w;c.x*=l,c.y*=l,c.z*=l,p[n].add(c.multiplyScalar(u[t]))}}const d=new t.Vector4(0,0,0,0);for(let t=0;t<=o;++t)d.add(p[t].multiplyScalar(v[t]));d.divideScalar(d.w),i.set(d.x,d.y,d.z)},exports.findSpan=function(t,e,o){const n=o.length-t-1;if(e>=o[n])return n-1;if(e<=o[t])return t;let c=t,r=n,l=Math.floor((c+r)/2);for(;e<o[l]||e>=o[l+1];)e<o[l]?r=l:c=l,l=Math.floor((c+r)/2);return l};

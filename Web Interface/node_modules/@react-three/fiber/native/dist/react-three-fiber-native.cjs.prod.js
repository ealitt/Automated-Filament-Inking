'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var THREE = require('three');
var expoAsset = require('expo-asset');
var index = require('../../dist/index-ff8b5912.cjs.prod.js');
var _extends = require('@babel/runtime/helpers/extends');
var React = require('react');
var reactNative = require('react-native');
var expoGl = require('expo-gl');
var Pressability = require('react-native/Libraries/Pressability/Pressability');
require('suspend-react');
require('react-reconciler/constants');
require('zustand');
require('react-reconciler');
require('scheduler');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var Pressability__default = /*#__PURE__*/_interopDefault(Pressability);

const EVENTS = {
  PRESS: 'onPress',
  PRESSIN: 'onPressIn',
  PRESSOUT: 'onPressOut',
  LONGPRESS: 'onLongPress',
  HOVERIN: 'onHoverIn',
  HOVEROUT: 'onHoverOut',
  PRESSMOVE: 'onPressMove'
};
const DOM_EVENTS = {
  [EVENTS.PRESS]: 'onClick',
  [EVENTS.PRESSIN]: 'onPointerDown',
  [EVENTS.PRESSOUT]: 'onPointerUp',
  [EVENTS.LONGPRESS]: 'onDoubleClick',
  [EVENTS.HOVERIN]: 'onPointerOver',
  [EVENTS.HOVEROUT]: 'onPointerOut',
  [EVENTS.PRESSMOVE]: 'onPointerMove'
};
function createTouchEvents(store) {
  const {
    handlePointer
  } = index.createEvents(store);

  const handleTouch = (event, name) => {
    event.persist() // Apply offset
    ;
    event.nativeEvent.offsetX = event.nativeEvent.locationX;
    event.nativeEvent.offsetY = event.nativeEvent.locationY; // Emulate DOM event

    const callback = handlePointer(DOM_EVENTS[name]);
    return callback(event.nativeEvent);
  };

  return {
    connected: false,
    handlers: Object.values(EVENTS).reduce((acc, name) => ({ ...acc,
      [name]: event => handleTouch(event, name)
    }), {}),
    connect: () => {
      const {
        set,
        events
      } = store.getState();
      events.disconnect == null ? void 0 : events.disconnect();
      const connected = new Pressability__default['default'](events == null ? void 0 : events.handlers);
      set(state => ({
        events: { ...state.events,
          connected
        }
      }));
      const handlers = connected.getEventHandlers();
      return handlers;
    },
    disconnect: () => {
      const {
        set,
        events
      } = store.getState();

      if (events.connected) {
        events.connected.reset();
        set(state => ({
          events: { ...state.events,
            connected: false
          }
        }));
      }
    }
  };
}

const CANVAS_PROPS = ['gl', 'events', 'shadows', 'linear', 'flat', 'orthographic', 'frameloop', 'performance', 'clock', 'raycaster', 'camera', 'onPointerMissed', 'onCreated'];

function Block({
  set
}) {
  React__namespace.useLayoutEffect(() => {
    set(new Promise(() => null));
    return () => set(false);
  }, [set]);
  return null;
}

class ErrorBoundary extends React__namespace.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      error: false
    };
  }

  componentDidCatch(error) {
    this.props.set(error);
  }

  render() {
    return this.state.error ? null : this.props.children;
  }

}

ErrorBoundary.getDerivedStateFromError = () => ({
  error: true
});

const Canvas = /*#__PURE__*/React__namespace.forwardRef(({
  children,
  fallback,
  style,
  events,
  ...props
}, forwardedRef) => {
  // Create a known catalogue of Threejs-native elements
  // This will include the entire THREE namespace by default, users can extend
  // their own elements by using the createRoot API instead
  React__namespace.useMemo(() => index.extend(THREE__namespace), []);
  const [{
    width,
    height
  }, setSize] = React__namespace.useState({
    width: 0,
    height: 0
  });
  const [canvas, setCanvas] = React__namespace.useState(null);
  const [bind, setBind] = React__namespace.useState();
  const canvasProps = index.pick(props, CANVAS_PROPS);
  const viewProps = index.omit(props, CANVAS_PROPS);
  const [block, setBlock] = React__namespace.useState(false);
  const [error, setError] = React__namespace.useState(false); // Suspend this component if block is a promise (2nd run)

  if (block) throw block; // Throw exception outwards if anything within canvas throws

  if (error) throw error;
  const onLayout = React__namespace.useCallback(e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    setSize({
      width,
      height
    });
  }, []);
  const onContextCreate = React__namespace.useCallback(context => {
    const canvasShim = {
      width: context.drawingBufferWidth,
      height: context.drawingBufferHeight,
      style: {},
      addEventListener: () => {},
      removeEventListener: () => {},
      clientHeight: context.drawingBufferHeight,
      getContext: () => context
    };
    setCanvas(canvasShim);
  }, []);

  if (width > 0 && height > 0 && canvas) {
    // Overwrite onCreated to apply RN bindings
    const onCreated = state => {
      // Bind events after creation
      const handlers = state.events.connect == null ? void 0 : state.events.connect(canvas);
      setBind(handlers); // Bind render to RN bridge

      const context = state.gl.getContext();
      const renderFrame = state.gl.render.bind(state.gl);

      state.gl.render = (scene, camera) => {
        renderFrame(scene, camera);
        context.endFrameEXP();
      };

      return canvasProps == null ? void 0 : canvasProps.onCreated == null ? void 0 : canvasProps.onCreated(state);
    };

    index.createRoot(canvas, { ...canvasProps,
      // expo-gl can only render at native dpr/resolution
      // https://github.com/expo/expo-three/issues/39
      dpr: reactNative.PixelRatio.get(),
      size: {
        width,
        height
      },
      events: events || createTouchEvents,
      onCreated
    }).render( /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
      set: setError
    }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {
      fallback: /*#__PURE__*/React__namespace.createElement(Block, {
        set: setBlock
      })
    }, children)));
  }

  React__namespace.useEffect(() => {
    return () => index.unmountComponentAtNode(canvas);
  }, [canvas]);
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends({}, viewProps, {
    ref: forwardedRef,
    onLayout: onLayout,
    style: {
      flex: 1,
      ...style
    }
  }, bind), width > 0 && /*#__PURE__*/React__namespace.createElement(expoGl.GLView, {
    onContextCreate: onContextCreate,
    style: reactNative.StyleSheet.absoluteFill
  }));
});

/**
 * Generates an asset based on input type.
 */

const getAsset = input => {
  if (input instanceof expoAsset.Asset) return input;

  switch (typeof input) {
    case 'string':
      return expoAsset.Asset.fromURI(input);

    case 'number':
      return expoAsset.Asset.fromModule(input);

    default:
      throw 'Invalid asset! Must be a URI or module.';
  }
}; // Don't pre-process urls, let expo-asset generate an absolute URL


THREE__namespace.LoaderUtils.extractUrlBase = () => './'; // There's no Image in native, so create a data texture instead


THREE__namespace.TextureLoader.prototype.load = function load(url, onLoad, onProgress, onError) {
  const texture = new THREE__namespace.Texture(); // @ts-expect-error

  texture.isDataTexture = true;
  getAsset(url).downloadAsync().then(asset => {
    texture.image = {
      data: asset,
      width: asset.width,
      height: asset.height
    };
    texture.needsUpdate = true;
    onLoad == null ? void 0 : onLoad(texture);
  }).catch(onError);
  return texture;
}; // Fetches assets via XMLHttpRequest


THREE__namespace.FileLoader.prototype.load = function (url, onLoad, onProgress, onError) {
  if (this.path) url = this.path + url;
  const request = new XMLHttpRequest();
  getAsset(url).downloadAsync().then(asset => {
    request.open('GET', asset.uri, true);
    request.addEventListener('load', event => {
      if (request.status === 200) {
        onLoad == null ? void 0 : onLoad(request.response);
        this.manager.itemEnd(url);
      } else {
        onError == null ? void 0 : onError(event);
        this.manager.itemError(url);
        this.manager.itemEnd(url);
      }
    }, false);
    request.addEventListener('progress', event => {
      onProgress == null ? void 0 : onProgress(event);
    }, false);
    request.addEventListener('error', event => {
      onError == null ? void 0 : onError(event);
      this.manager.itemError(url);
      this.manager.itemEnd(url);
    }, false);
    request.addEventListener('abort', event => {
      onError == null ? void 0 : onError(event);
      this.manager.itemError(url);
      this.manager.itemEnd(url);
    }, false);
    if (this.responseType) request.responseType = this.responseType;
    if (this.withCredentials) request.withCredentials = this.withCredentials;

    for (const header in this.requestHeader) {
      request.setRequestHeader(header, this.requestHeader[header]);
    }

    request.send(null);
    this.manager.itemStart(url);
  });
  return request;
};

exports.ReactThreeFiber = index.threeTypes;
exports._roots = index.roots;
exports.act = index.act;
exports.addAfterEffect = index.addAfterEffect;
exports.addEffect = index.addEffect;
exports.addTail = index.addTail;
exports.advance = index.advance;
exports.applyProps = index.applyProps;
exports.context = index.context;
exports.createPortal = index.createPortal;
exports.createRoot = index.createRoot;
exports.dispose = index.dispose;
exports.extend = index.extend;
exports.invalidate = index.invalidate;
exports.reconciler = index.reconciler;
exports.render = index.render;
exports.unmountComponentAtNode = index.unmountComponentAtNode;
exports.useFrame = index.useFrame;
exports.useGraph = index.useGraph;
exports.useLoader = index.useLoader;
exports.useStore = index.useStore;
exports.useThree = index.useThree;
exports.Canvas = Canvas;
exports.events = createTouchEvents;
